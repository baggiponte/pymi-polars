---
title: ğŸ¼ What are `pandas` limits?
---

# ğŸ¼ What are `pandas` limits?

Time for a little guessing game

<v-clicks>

<blockquote style='font-size:18px'>
"Nowadays, my rule of thumb for <code>pandas</code> is that you should have <b>5 to 10 times as much RAM as the size of your dataset</b>"
</blockquote>

<p align='right'><i>Wes McKinney, <code>pandas</code> creator and co-founder/CTO of Voltron Data</i></p>

<blockquote style='font-size:18px'>
"But first, itâ€™s worth considering not using pandas [when scaling to large datasets]"
</blockquote>

<p align='right'><i><code>pandas</code> documentation</i></p>

</v-clicks>


---

# ğŸ¼ What are `pandas` limits?
A little rundown


<v-clicks>

* Single-threaded: cannot be natively parallelised (could be handy with `groupby` operations).
* Eager mode:
  * Must work with data in-memory (batching is not really an option: just [4 results](https://pandas.pydata.org/docs/search.html?q=batch) when scanning the docs).
  * Code is executed line by line and cannot be optimised by a query engine.
* Lots of expensive copies are created:

</v-clicks>

<v-click>

<blockquote style='font-size:18px'>

When you write `df[df.c < 0].d.sum()`, pandas creates a temporary DataFrame `df[df.c < 0]` then sums the d column of that temporary object. If df contains a lot of columns, this is ridiculously wasteful. 
</blockquote>
</v-click>

<v-click>

* Appending is costly because the `index` is rebuilt every time
  * use `pd.concat(list_of_small_dataframes)`
</v-click>


---

# ğŸ¼ What are `pandas` limits?
A little rundown

<v-clicks>

* Really expressive syntax, but can be complex/non-intuitive/not-pythonic/inefficient.
* This is especially true of the functional, modern syntax:
  * must resort to `lambdas`.

</v-clicks>

<v-after>

```python{5-7}
import pandas as pd

data = pd.read_csv("path/to/my/file.csv")

data.assign(
    new_col = lambda df: df["old_col"].apply(udf, *args, **kwargs)
)
```

</v-after>


---

# ğŸ‹ Bonus slide: modern `pandas`
A lesson from the `R` crowd

<v-clicks>

Would always recommend the [method chaining](https://tomaugspurger.github.io/posts/method-chaining/), and use the object oriented one within UDF.

* Elegant syntax with lots of nifty tricks
* Visually helpful in isolating pipelines
</v-clicks>


<v-click>

```python{all|9-10|11}
import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(15, 5))

(
    df.filter(['fl_date', 'tail_num', 'dep_time', 'dep_delay'])
      .dropna()
      .assign(hour=lambda x: x.dep_time.dt.hour)
      .query('5 < dep_delay < 600')
      .pipe((sns.boxplot, 'data'), 'hour', 'dep_delay')
)

sns.despine()
```
</v-click>


